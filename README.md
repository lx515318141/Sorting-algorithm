# 排序算法(此代码都使用伪代码)

## 01冒泡排序

原理：从第一个数开始，进行两两比较，较大的一个向后移，一直到最后一个数，此时最大的数已经在最后一位，然后不看最后一个数，让前面的数用同样的方法再将最大的一个数放到倒数第二位，以此类推，最后完成排序。
时间复杂度：稳定 O(n^2)  
空间复杂度：O(1)  

## 02选择排序

时间复杂度：不稳定 O(n^2)  
空间复杂度：O(1)  

## 03插入排序

时间复杂度：稳定 O(n^2)  
空间复杂度：O(1)  

## 04希尔排序

时间复杂度：不稳定 O(n^1.2)  
空间复杂度：O(1)  

## 05归并排序

时间复杂度：稳定 O(nlog2*n)  
空间复杂度：O(n)  

## 07堆排序

时间复杂度：不稳定 O(nlog2*n)  
空间复杂度：O(1)  

## 08计数排序

原理：计数排分为入桶及出桶，两个过程。  
a.入桶：将要排序的数组也就是原数组的value，作为key，每个数字在原数组中出现的次数作为value，放入另一个数组，作为桶(使用for循环)。  
b.出桶：出桶前选确定桶的length，桶的length为原数组最大值+1，所以应先确定原数组中最大值(使用for循环)。然后遍历桶，将value不为undefined的key再push到一个新数组里面(使用if判断内嵌for循环)，此key的value为几，就push几次。最后得到的新数组就是排序好的数组。  

时间复杂度：稳定 O(n+k)  
空间复杂度：O(n+k)   

优点：复杂度(n+max),可以比快排还快。  
缺点：  
a.需要另一个hash作为桶，来计算每一个数出现的次数，且浪费很多hash内的空间，这个hash的长度为原数组最大值加一。  
b.无法排序小数和负数。

## 09桶排序

时间复杂度：稳定 O(n+k)  
空间复杂度：O(n+k)  

## 10基数排序

时间复杂度：稳定 O(n*k)  
空间复杂度：O(n+k)  

